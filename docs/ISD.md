# Контрольная работа по дисциплине "Введение в разработку программного обеспечения"

**Тема:** Разработка REST API приложения для управления личными финансами (CashFlow API)

---

## Содержание

1. [Требования к ПС (все требования)](#1-требования-к-пс-все-требования)
2. [Итеративный план разработки](#2-итеративный-план-разработки)
3. [Архитектура программы (в т.ч. каркас, паттерны типа MVC)](#3-архитектура-программы-в-тч-каркас-паттерны-типа-mvc)
4. [Кратко - основные классы-сущности. Структура БД](#4-кратко---основные-классы-сущности-структура-бд)
5. [Диаграмма классов (по итерациям!) программы](#5-диаграмма-классов-по-итерациям-программы)
6. [Модульные тесты для классов](#6-модульные-тесты-для-классов)
7. [Список и описание рефакторингов (по итерациям). Перечислить паттерны GoF, примененные при рефакторинге](#7-список-и-описание-рефакторингов-по-итерациям-перечислить-паттерны-gof-примененные-при-рефакторинге)
8. [Упаковка проекта, метрики упаковки (в т.ч. - докер, если есть, вопросы CI/CD, взаимодействие сервисов и компонентов через RabbitMQ – если будет). Нужно привести результаты отдельных итераций / версий как результаты набора коммитов в системе контроля версий](#8-упаковка-проекта-метрики-упаковки)

---

## Введение

В современном мире управление личными финансами становится все более актуальной задачей. Развитие информационных технологий позволяет создавать эффективные программные решения для учета доходов и расходов, анализа финансовых потоков и планирования бюджета.

Данная контрольная работа посвящена разработке REST API приложения для управления личными финансами под названием **CashFlow API**. Приложение предоставляет пользователям возможность отслеживать свои доходы и расходы, организовывать транзакции по категориям и получать детальную финансовую аналитику.

**Цель работы:** Разработать полнофункциональное REST API приложение с использованием современных технологий и паттернов проектирования, демонстрирующее применение принципов объектно-ориентированного программирования и лучших практик разработки программного обеспечения.

**Задачи работы:**
1. Спроектировать и реализовать архитектуру приложения с использованием многослойной архитектуры
2. Применить паттерны проектирования GoF (Gang of Four) для обеспечения гибкости и расширяемости системы
3. Реализовать функциональность управления пользователями, категориями и транзакциями
4. Разработать систему финансовой аналитики с фильтрацией по датам
5. Обеспечить качество кода через модульное тестирование
6. Упаковать приложение в Docker контейнеры для упрощения развертывания

**Используемые технологии:**
- **Backend Framework:** NestJS - современный Node.js фреймворк для построения масштабируемых серверных приложений
- **Язык программирования:** TypeScript - типизированное надмножество JavaScript
- **База данных:** PostgreSQL - реляционная СУБД для хранения данных
- **ORM:** TypeORM - объектно-реляционное отображение для работы с БД
- **Аутентификация:** JWT (JSON Web Tokens) - токены для авторизации пользователей
- **Документация API:** Swagger/OpenAPI - автоматическая генерация документации
- **Контейнеризация:** Docker и Docker Compose - упаковка и оркестрация контейнеров

**Применяемые паттерны проектирования:**
В процессе разработки были применены следующие паттерны из каталога GoF:
- **Repository Pattern** - для абстракции работы с данными
- **Strategy Pattern** - для выбора источника данных во время выполнения
- **Abstract Factory Pattern** - для создания семейств связанных объектов
- **Observer Pattern** - для обработки событий транзакций

**Методология разработки:**
Проект разрабатывался итеративно с постепенным наращиванием функциональности. Первая версия (v1.0) включала базовую функциональность для выполнения всех use cases. Вторая версия (v2.0) была создана в результате рефакторинга с применением паттернов проектирования, что значительно улучшило архитектуру, тестируемость и расширяемость приложения.

**Структура документации:**
Данная документация структурирована в соответствии с требованиями контрольной работы и включает описание всех этапов разработки: от постановки требований до упаковки проекта. Каждый раздел содержит детальное описание соответствующего аспекта проекта с примерами кода, диаграммами и метриками.

---

## 1. Требования к ПС (все требования)

### 1.1 Функциональные требования

#### FR1: Аутентификация и авторизация
- **FR1.1:** Система должна предоставлять возможность регистрации новых пользователей с уникальным username и password
- **FR1.2:** Система должна предоставлять возможность входа в систему зарегистрированных пользователей
- **FR1.3:** Система должна использовать JWT токены для авторизации пользователей
- **FR1.4:** Система должна защищать пароли пользователей с помощью хеширования (bcrypt)

#### FR2: Управление категориями
- **FR2.1:** Система должна позволять пользователям создавать категории для группировки транзакций
- **FR2.2:** Каждая категория должна иметь уникальное имя в рамках пользователя
- **FR2.3:** Категория должна иметь тип: "income" (доход) или "expense" (расход)
- **FR2.4:** Система должна предоставлять возможность просмотра списка всех категорий пользователя
- **FR2.5:** Система должна предоставлять возможность просмотра категории по ID
- **FR2.6:** Система должна предоставлять возможность обновления категории
- **FR2.7:** Система должна предоставлять возможность удаления категории
- **FR2.8:** При регистрации пользователя система должна автоматически создавать набор категорий по умолчанию

#### FR3: Управление транзакциями
- **FR3.1:** Система должна позволять пользователям создавать транзакции (доходы и расходы)
- **FR3.2:** Транзакция должна содержать: сумму (amount), тип (income/expense), опциональную заметку (note), опциональную категорию
- **FR3.3:** Система должна предоставлять возможность просмотра списка всех транзакций пользователя
- **FR3.4:** Система должна предоставлять возможность просмотра транзакции по ID
- **FR3.5:** Система должна автоматически присваивать транзакции дату создания
- **FR3.6:** Система должна валидировать принадлежность транзакции пользователю

#### FR4: Финансовая аналитика
- **FR4.1:** Система должна предоставлять общую финансовую аналитику: общие доходы, общие расходы, баланс (доходы - расходы)
- **FR4.2:** Система должна предоставлять аналитику по категориям: сумма, количество транзакций, процент от общей суммы
- **FR4.3:** Система должна поддерживать фильтрацию аналитики по датам (startDate, endDate)
- **FR4.4:** Система должна валидировать корректность диапазона дат

### 1.2 Нефункциональные требования

#### NFR1: Производительность
- **NFR1.1:** API должен обрабатывать запросы со временем ответа не более 500ms для стандартных операций
- **NFR1.2:** Система должна поддерживать работу с базой данных PostgreSQL

#### NFR2: Безопасность
- **NFR2.1:** Все пароли должны храниться в хешированном виде
- **NFR2.2:** API должен использовать JWT токены для авторизации
- **NFR2.3:** Защищенные эндпоинты должны требовать валидный JWT токен

#### NFR3: Надежность
- **NFR3.1:** Система должна обрабатывать ошибки и возвращать корректные HTTP статус-коды
- **NFR3.2:** Система должна валидировать входные данные

#### NFR4: Расширяемость
- **NFR4.1:** Система должна поддерживать работу с разными источниками данных (БД, мок, файл)
- **NFR4.2:** Архитектура должна позволять легко добавлять новые функциональные модули

#### NFR5: Тестируемость
- **NFR5.1:** Код должен быть покрыт модульными тестами
- **NFR5.2:** Тесты должны использовать моки для изоляции от реальной БД

#### NFR6: Документация
- **NFR6.1:** API должен иметь документацию в формате Swagger/OpenAPI
- **NFR6.2:** Код должен содержать комментарии и документацию

### 1.3 Технические требования

#### TR1: Технологический стек
- **TR1.1:** Backend: NestJS (Node.js фреймворк)
- **TR1.2:** Язык программирования: TypeScript
- **TR1.3:** База данных: PostgreSQL
- **TR1.4:** ORM: TypeORM
- **TR1.5:** Аутентификация: JWT (JSON Web Tokens)
- **TR1.6:** Документация API: Swagger/OpenAPI

#### TR2: Инфраструктура
- **TR2.1:** Приложение должно быть упаковано в Docker контейнеры
- **TR2.2:** Использование Docker Compose для оркестрации контейнеров
- **TR2.3:** Поддержка переменных окружения для конфигурации

#### TR3: Качество кода
- **TR3.1:** Использование паттернов проектирования GoF
- **TR3.2:** Следование принципам SOLID
- **TR3.3:** Модульная архитектура с разделением ответственности

---

## 2. Итеративный план разработки

### 2.1 Общая стратегия разработки

Проект разрабатывался итеративно с постепенным наращиванием функциональности. Каждая итерация добавляла новые use cases и улучшала архитектуру приложения.

### 2.2 План итераций

#### Итерация 1 (Версия 1.0 - Базовая функциональность)
**Срок:** Начало декабря  
**Цель:** Реализация базовой функциональности аутентификации и работы с транзакциями

**Реализованные Use Cases:**
- UC1: Регистрация пользователя
- UC2: Вход в систему
- UC3: Создание транзакции
- UC4: Просмотр списка транзакций
- UC5: Просмотр транзакции по ID

**Задачи:**
- Настройка проекта NestJS
- Создание модуля аутентификации (Auth)
- Реализация регистрации и входа
- Настройка JWT токенов
- Создание модуля пользователей (Users)
- Настройка базы данных PostgreSQL
- Создание модуля транзакций (Transactions)
- Реализация CRUD операций для транзакций
- Создание сущности Transaction
- Настройка связей между User и Transaction

**Результаты:**
- Работающая система аутентификации
- Базовая структура проекта
- Подключение к базе данных
- Полная функциональность работы с транзакциями
- Валидация данных транзакций
- Проверка принадлежности транзакций пользователю

---

#### Итерация 2 (Версия 1.0 - Категории и финансовая аналитика)
**Срок:** Начало декабря  
**Цель:** Реализация функциональности работы с категориями и финансовой аналитики

**Реализованные Use Cases:**
- UC6: Получение финансовой аналитики
- UC7: Получение аналитики по категориям
- UC8: Создание категории
- UC9: Просмотр списка категорий
- UC10: Просмотр категории по ID
- UC11: Обновление категории
- UC12: Удаление категории

**Задачи:**
- Создание модуля категорий (Categories)
- Реализация CRUD операций для категорий
- Создание сущности Category
- Настройка связей между User, Category и Transaction
- Автоматическое создание категорий по умолчанию при регистрации
- Реализация алгоритмов расчета аналитики
- Фильтрация по датам
- Группировка транзакций по категориям
- Вычисление статистики (суммы, проценты)
- Обработка каскадного удаления

**Результаты:**
- Полная функциональность работы с категориями
- Валидация уникальности категорий
- Связь транзакций с категориями
- Полная финансовая аналитика
- Фильтрация по датам
- Детальная аналитика по категориям
- Завершение версии 1.0

---

#### Итерация 3 (Версия 2.0 - Рефакторинг и паттерны проектирования)
**Срок:** Середина декабря  
**Цель:** Улучшение архитектуры с использованием паттернов проектирования GoF

**Задачи:**
- Создание модуля `common/` для общих паттернов
- Внедрение Repository Pattern для абстракции работы с данными
- Внедрение Strategy Pattern для источников данных
- Внедрение Abstract Factory Pattern для создания источников данных
- Внедрение Observer Pattern для обработки событий транзакций
- Рефакторинг сервисов для использования паттернов
- Создание MockDataSource для тестирования

**Результаты:**
- Модульная архитектура с паттернами GoF
- Улучшенная тестируемость через абстракции
- Гибкость в выборе источников данных
- Слабая связанность компонентов
- Возможность легкого расширения функциональности

---

#### Итерация 4 (Версия 2.0 - Тестирование и упаковка)
**Срок:** Конец декабря  
**Цель:** Покрытие кода модульными тестами и упаковка проекта в Docker

**Задачи:**
- Написание модульных тестов для сервисов
- Использование MockDataSource для изоляции тестов
- Тестирование контроллеров
- Настройка Jest для тестирования
- Создание Dockerfile для упаковки приложения
- Настройка Docker Compose для оркестрации контейнеров
- Конфигурация переменных окружения
- Настройка health checks для контейнеров

**Результаты:**
- Покрытие тестами основных модулей
- Изоляция тестов от реальной БД
- Быстрое выполнение тестов
- Упакованное приложение в Docker контейнерах
- Готовность к развертыванию
- Завершение версии 2.0

---

### 2.3 Таблица плана итераций

| Итерация | Версия | Use Cases | Сложность (ид. дней) | Статус |
|----------|--------|-----------|---------------------|--------|
| 1        | 1.0    | UC1-UC5   | 5                   | ✅ Выполнено |
| 2        | 1.0    | UC6-UC12  | 6                   | ✅ Выполнено |
| 3        | 2.0    | Рефакторинг, паттерны | 3      | ✅ Выполнено |
| 4        | 2.0    | Тесты, упаковка | 4          | ✅ Выполнено |

---

## 3. Архитектура программы (в т.ч. каркас, паттерны типа MVC)

### 3.1 Общая архитектура

Проект построен на основе **многослойной архитектуры (Layered Architecture)** с использованием фреймворка NestJS. Архитектура следует принципам разделения ответственности и обеспечивает четкое разделение между слоями представления, бизнес-логики и доступа к данным.

### 3.2 Архитектурные слои

#### 3.2.1 Controller Layer (Слой контроллеров)
**Назначение:** Обработка HTTP-запросов, валидация входных данных и формирование ответов.

**Компоненты:**
- `AuthController` - обработка запросов аутентификации
- `UsersController` - обработка запросов пользователей
- `CategoriesController` - обработка запросов категорий
- `TransactionsController` - обработка запросов транзакций

**Ответственность:**
- Прием HTTP-запросов
- Валидация входных данных (DTO)
- Вызов методов сервисов
- Формирование HTTP-ответов
- Обработка ошибок

#### 3.2.2 Service Layer (Слой сервисов)
**Назначение:** Содержит бизнес-логику приложения.

**Компоненты:**
- `AuthService` - бизнес-логика аутентификации
- `UsersService` - бизнес-логика пользователей
- `CategoriesService` - бизнес-логика категорий
- `TransactionsService` - бизнес-логика транзакций и аналитики

**Ответственность:**
- Реализация бизнес-правил
- Координация работы с репозиториями
- Обработка событий через Observer Pattern
- Вычисление аналитики

#### 3.2.3 Repository Layer (Слой репозиториев)
**Назначение:** Абстрагирует доступ к данным.

**Компоненты:**
- `AbstractRepository<T>` - абстрактный базовый класс
- `TransactionRepository` - репозиторий транзакций
- `CategoryRepository` - репозиторий категорий

**Ответственность:**
- Абстракция работы с данными
- Изоляция бизнес-логики от деталей БД
- Упрощение тестирования

#### 3.2.4 Data Source Layer (Слой источников данных)
**Назначение:** Реализация различных стратегий работы с данными.

**Компоненты:**
- `IDataSource` - интерфейс стратегии
- `DatabaseDataSource` - стратегия для PostgreSQL
- `MockDataSource` - стратегия для тестирования
- `DataSourceFactory` - фабрика для создания источников

**Ответственность:**
- Реализация Strategy Pattern
- Переключение между источниками данных
- Изоляция логики работы с данными

#### 3.2.5 Entity Layer (Слой сущностей)
**Назначение:** Модели предметной области.

**Компоненты:**
- `User` - сущность пользователя
- `Transaction` - сущность транзакции
- `Category` - сущность категории

**Ответственность:**
- Определение структуры данных
- Связи между сущностями
- Валидация на уровне сущностей

### 3.3 Паттерн MVC в контексте NestJS

NestJS использует архитектурный паттерн, похожий на MVC, но адаптированный для современных веб-приложений:

- **Model (Модель):** Представлены Entity классами (User, Transaction, Category) и DTO классами
- **View (Представление):** В REST API представление - это JSON ответы, формируемые контроллерами
- **Controller (Контроллер):** Контроллеры NestJS обрабатывают HTTP-запросы и делегируют работу сервисам

**Отличия от классического MVC:**
- Вместо View используется формирование JSON ответов
- Добавлен слой Service для бизнес-логики
- Используется Dependency Injection для связывания компонентов

### 3.4 Структура модулей

Каждый функциональный модуль организован по единому принципу:

```
module/
├── entities/          # Сущности предметной области
├── dto/              # Data Transfer Objects (DTO)
├── interfaces/       # Интерфейсы для типизации
├── module.controller.ts  # Контроллер (обработка HTTP)
├── module.service.ts     # Сервис (бизнес-логика)
└── module.module.ts      # Модуль NestJS
```

### 3.5 Полная структура проекта

```
src/
├── auth/              # Модуль аутентификации
│   ├── guards/        # Guards для защиты маршрутов
│   ├── decorators/    # Кастомные декораторы
│   ├── dto/           # DTO для аутентификации
│   └── ...
├── users/             # Модуль пользователей
│   ├── entities/      # User entity
│   ├── dto/           # DTO для создания/обновления
│   └── ...
├── categories/        # Модуль категорий
│   ├── entities/      # Category entity
│   ├── dto/           # DTO для категорий
│   └── ...
├── transactions/      # Модуль транзакций
│   ├── entities/      # Transaction entity
│   ├── dto/           # DTO для транзакций и аналитики
│   └── ...
├── common/            # Общие паттерны и утилиты
│   ├── repositories/  # Repository Pattern
│   ├── data-sources/  # Strategy и Abstract Factory
│   └── observers/      # Observer Pattern
└── database/          # Конфигурация БД
    └── orm/           # TypeORM конфигурация
```

### 3.6 Принципы проектирования

#### SOLID принципы:
- **S (Single Responsibility):** Каждый класс имеет одну ответственность
- **O (Open/Closed):** Классы открыты для расширения, закрыты для модификации
- **L (Liskov Substitution):** Подклассы могут заменять базовые классы
- **I (Interface Segregation):** Интерфейсы разделены по функциональности
- **D (Dependency Inversion):** Зависимости через абстракции, не конкретные классы

#### DRY (Don't Repeat Yourself):
- Общие паттерны вынесены в модуль `common/`
- Переиспользование кода через наследование и композицию

#### Separation of Concerns:
- Четкое разделение между слоями
- Изоляция бизнес-логики от деталей реализации

---

## 4. Кратко - основные классы-сущности. Структура БД

### 4.1 Основные классы-сущности

#### User (Пользователь)
**Описание:** Центральная сущность системы, представляет пользователя приложения.

**Поля:**
- `id: string` - уникальный идентификатор (UUID)
- `username: string` - уникальное имя пользователя (макс. 64 символа)
- `password_hash: string` - хеш пароля (скрыт в API)
- `created_at: Date` - дата создания

**Связи:**
- 1:N с Transaction (один пользователь имеет множество транзакций)
- 1:N с Category (один пользователь имеет множество категорий)

#### Transaction (Транзакция)
**Описание:** Представляет доход или расход пользователя.

**Поля:**
- `id: string` - уникальный идентификатор (UUID)
- `amount: number` - сумма транзакции (decimal с 2 знаками после запятой)
- `type: 'income' | 'expense'` - тип транзакции (доход или расход)
- `note: string | null` - опциональная заметка
- `created_at: Date` - дата создания транзакции

**Связи:**
- N:1 с User (множество транзакций принадлежат одному пользователю)
- N:0..1 с Category (транзакция может относиться к категории или не иметь её)

#### Category (Категория)
**Описание:** Группирует транзакции по типам для организации финансов.

**Поля:**
- `id: string` - уникальный идентификатор (UUID)
- `name: string` - название категории (уникально в рамках пользователя)
- `type: 'income' | 'expense'` - тип категории (доход или расход)
- `created_at: Date` - дата создания категории

**Связи:**
- N:1 с User (множество категорий принадлежат одному пользователю)
- 1:N с Transaction (одна категория может иметь множество транзакций)

### 4.2 Структура базы данных

#### Таблица `users`
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(64) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Индексы:**
- `username` - уникальный индекс

#### Таблица `categories`
```sql
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    type VARCHAR(10) NOT NULL CHECK (type IN ('income', 'expense')),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, name)
);
```

**Индексы:**
- `user_id` - внешний ключ на users(id)
- `(user_id, name)` - составной уникальный индекс

#### Таблица `transactions`
```sql
CREATE TABLE transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    amount DECIMAL(10, 2) NOT NULL,
    type VARCHAR(10) NOT NULL CHECK (type IN ('income', 'expense')),
    note TEXT,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    category_id UUID REFERENCES categories(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**Индексы:**
- `user_id` - внешний ключ на users(id)
- `category_id` - внешний ключ на categories(id)
- `created_at` - индекс для сортировки по дате

### 4.3 Диаграмма связей сущностей

```
User (1) ────────< (N) Transaction
  │
  │ (1)
  │
  └───────< (N) Category (1) ────────< (N) Transaction
```

**Описание связей:**
- **User → Transaction:** Один пользователь может иметь множество транзакций. При удалении пользователя все его транзакции удаляются (CASCADE).
- **User → Category:** Один пользователь может иметь множество категорий. При удалении пользователя все его категории удаляются (CASCADE).
- **Category → Transaction:** Одна категория может иметь множество транзакций. При удалении категории транзакции остаются, но category_id становится NULL (SET NULL).

### 4.4 Ограничения целостности

1. **Уникальность username:** Каждый пользователь должен иметь уникальное имя пользователя
2. **Уникальность категории:** Комбинация (user_id, name) должна быть уникальной
3. **Каскадное удаление:** При удалении пользователя удаляются все его транзакции и категории
4. **SET NULL для category_id:** При удалении категории транзакции не удаляются, но теряют связь с категорией

---

## 5. Диаграмма классов (по итерациям!) программы

Диаграммы классов показывают эволюцию архитектуры проекта от базовой функциональности до полноценного приложения с паттернами проектирования. Каждая итерация добавляла новые классы и улучшала структуру проекта.

### 5.1 Итерация 1: Базовая функциональность (Версия 1.0)

**Реализованные Use Cases:** UC1-UC5

На первой итерации была реализована базовая структура приложения без использования паттернов проектирования.

**Основные классы:**
- `User` - сущность пользователя
- `Transaction` - сущность транзакции
- `AuthService`, `AuthController` - модуль аутентификации
- `UsersService` - модуль пользователей
- `TransactionsService`, `TransactionsController` - модуль транзакций

**Характеристики:**
- Прямое использование TypeORM репозиториев в сервисах
- Отсутствие абстракции для работы с данными
- Простая структура без общего модуля
- Базовая функциональность CRUD операций

**Диаграмма классов:**

PlantUML диаграмма доступна в файле `docs/diagrams/iteration1-class-diagram.puml`.

**Основные связи:**
- `User` 1:N `Transaction` - один пользователь имеет множество транзакций
- `AuthController` → `AuthService` - контроллер использует сервис
- `TransactionsController` → `TransactionsService` - контроллер использует сервис
- `TransactionsService` → `Repository<Transaction>` - прямое использование TypeORM

**Особенности архитектуры:**
- Тесная связанность сервисов с TypeORM
- Отсутствие абстракции для работы с данными
- Простая структура без паттернов проектирования

---

### 5.2 Итерация 2: Категории и финансовая аналитика (Версия 1.0)

**Реализованные Use Cases:** UC6-UC12

На второй итерации добавлены категории и реализована финансовая аналитика.

**Новые классы:**
- `Category` - сущность категории
- `CategoriesService`, `CategoriesController` - модуль категорий
- Методы аналитики в `TransactionsService`: `getFinancialAnalytics()`, `getCategoryAnalytics()`
- DTO для аналитики: `FinancialAnalyticsDto`, `CategoryAnalyticsDto`, `AnalyticsQueryDto`

**Характеристики:**
- Расширенная модель данных с категориями
- Реализация алгоритмов финансовой аналитики
- Фильтрация по датам
- Группировка транзакций по категориям
- Вычисление статистики (суммы, проценты)

**Диаграмма классов:**

PlantUML диаграмма доступна в файле `docs/diagrams/iteration2-class-diagram.puml`.

**Основные связи:**
- `User` 1:N `Category` - один пользователь имеет множество категорий
- `Category` 1:N `Transaction` - одна категория может иметь множество транзакций
- `Transaction` N:0..1 `Category` - транзакция может относиться к категории или не иметь её
- `TransactionsService` → `Repository<Category>` - использование категорий в аналитике
- `CategoriesService` → `Repository<Category>` - полный CRUD для категорий

**Особенности архитектуры:**
- Полная модель предметной области (User, Transaction, Category)
- Реализация бизнес-логики аналитики
- Валидация данных на уровне сервисов
- Завершение версии 1.0

---

### 5.3 Итерация 3: Рефакторинг и паттерны проектирования (Версия 2.0)

**Цель:** Улучшение архитектуры с использованием паттернов проектирования GoF

На третьей итерации был проведен рефакторинг с внедрением паттернов проектирования.

**Новые классы и интерфейсы:**

**Repository Pattern:**
- `AbstractRepository<T>` - абстрактный базовый класс репозитория
- `TransactionRepository` - конкретный репозиторий для транзакций
- `CategoryRepository` - конкретный репозиторий для категорий

**Strategy Pattern:**
- `IDataSource` - интерфейс стратегии источника данных
- `DatabaseDataSource` - стратегия для работы с PostgreSQL
- `MockDataSource` - стратегия для тестирования (данные в памяти)

**Abstract Factory Pattern:**
- `DataSourceFactory` - абстрактная фабрика
- `DataSourceFactoryImpl` - конкретная реализация фабрики
- `DataSourceType` - перечисление типов источников данных

**Observer Pattern:**
- `ITransactionObserver` - интерфейс наблюдателя
- `AbstractTransactionObserver` - абстрактный класс наблюдателя
- `AnalyticsObserver` - конкретный наблюдатель для логирования
- `TransactionSubject` - субъект для управления наблюдателями

**Диаграмма классов:**

PlantUML диаграмма доступна в файле `docs/diagrams/iteration3-class-diagram.puml`.

**Основные связи:**

**Repository Pattern:**
- `AbstractRepository<T>` ← `TransactionRepository` (extends)
- `AbstractRepository<T>` ← `CategoryRepository` (extends)
- `TransactionsService` → `TransactionRepository` (uses)
- `CategoriesService` → `CategoryRepository` (uses)

**Strategy Pattern:**
- `IDataSource` ← `DatabaseDataSource` (implements)
- `IDataSource` ← `MockDataSource` (implements)

**Abstract Factory Pattern:**
- `DataSourceFactory` ← `DataSourceFactoryImpl` (extends)
- `DataSourceFactoryImpl` → `DatabaseDataSource` (creates)
- `DataSourceFactoryImpl` → `MockDataSource` (creates)

**Observer Pattern:**
- `ITransactionObserver` ← `AbstractTransactionObserver` (implements)
- `AbstractTransactionObserver` ← `AnalyticsObserver` (extends)
- `TransactionSubject` → `ITransactionObserver[]` (manages)
- `TransactionsService` → `TransactionSubject` (uses)

**Особенности архитектуры:**
- Модульная архитектура с паттернами GoF
- Изоляция бизнес-логики от деталей работы с БД
- Гибкость в выборе источников данных
- Слабая связанность компонентов через Observer Pattern
- Возможность легкого расширения функциональности

---

### 5.4 Итерация 4: Тестирование и упаковка (Версия 2.0)

**Цель:** Покрытие кода модульными тестами и упаковка проекта в Docker

На четвертой итерации добавлены модульные тесты и упаковка проекта.

**Новые компоненты:**

**Тестовые классы:**
- `TransactionsServiceSpec` - тесты для TransactionsService
- `CategoriesServiceSpec` - тесты для CategoriesService
- `AuthServiceSpec` - тесты для AuthService
- `TransactionsControllerSpec` - тесты для TransactionsController
- `CategoriesControllerSpec` - тесты для CategoriesController

**Docker конфигурация:**
- `Dockerfile` - многоэтапная сборка приложения
- `DockerCompose` - оркестрация контейнеров (API + Database)

**Диаграмма классов:**

PlantUML диаграмма доступна в файле `docs/diagrams/iteration4-class-diagram.puml`.

**Основные связи:**

**Тестирование:**
- `TransactionsServiceSpec` → `TransactionsService` (tests)
- `TransactionsServiceSpec` → `MockDataSource` (uses)
- `CategoriesServiceSpec` → `CategoriesService` (tests)
- `CategoriesServiceSpec` → `MockDataSource` (uses)
- `AuthServiceSpec` → `AuthService` (tests)
- `AuthServiceSpec` → `MockDataSource` (uses)
- `TransactionsControllerSpec` → `TransactionsController` (tests)
- `CategoriesControllerSpec` → `CategoriesController` (tests)

**Упаковка:**
- `Dockerfile` → `node:22.13.0-alpine` (base image)
- `DockerCompose` → `api` service (application)
- `DockerCompose` → `database` service (PostgreSQL)

**Особенности архитектуры:**
- Покрытие тестами основных модулей
- Использование `MockDataSource` для изоляции тестов
- Быстрое выполнение тестов (без обращения к БД)
- Упакованное приложение в Docker контейнерах
- Готовность к развертыванию
- Завершение версии 2.0

---

### 5.5 Использование PlantUML диаграмм

Все диаграммы классов созданы в формате PlantUML и доступны в папке `docs/diagrams/`:

- **Итерация 1:** `docs/diagrams/iteration1-class-diagram.puml`
- **Итерация 2:** `docs/diagrams/iteration2-class-diagram.puml`
- **Итерация 3:** `docs/diagrams/iteration3-class-diagram.puml`
- **Итерация 4:** `docs/diagrams/iteration4-class-diagram.puml`

**Как использовать диаграммы:**

1. **Онлайн генерация:**
   - Откройте [PlantUML Online Server](http://www.plantuml.com/plantuml/uml/)
   - Скопируйте содержимое нужного `.puml` файла
   - Вставьте в редактор
   - Диаграмма сгенерируется автоматически

2. **Локальная генерация:**
   ```bash
   # Установка PlantUML (через npm)
   npm install -g node-plantuml
   
   # Генерация PNG
   plantuml -tpng docs/diagrams/iteration*.puml
   
   # Генерация SVG
   plantuml -tsvg docs/diagrams/iteration*.puml
   ```

3. **Вставка в документ:**
   После генерации изображений их можно вставить в документ:
   ```markdown
   ![Диаграмма классов - Итерация 1](diagrams/iteration1-class-diagram.png)
   ```

**Эволюция архитектуры:**

Диаграммы показывают эволюцию проекта:
- **Итерация 1:** Простая структура с прямым использованием TypeORM
- **Итерация 2:** Расширенная модель данных с категориями и аналитикой
- **Итерация 3:** Рефакторинг с применением паттернов GoF
- **Итерация 4:** Тестирование и упаковка для production

Каждая итерация улучшала архитектуру, добавляя новые возможности и повышая качество кода.

---

## 6. Модульные тесты для классов

### 6.1 Стратегия тестирования

Для обеспечения качества кода написаны модульные тесты с использованием моков. Все тесты используют `MockDataSource` для изоляции от реальной базы данных, что обеспечивает:

- Быстрое выполнение тестов (без обращения к БД)
- Изоляцию тестов друг от друга
- Возможность тестирования граничных случаев
- Независимость от состояния БД

### 6.2 Тестирование сервисов

#### 6.2.1 TransactionsService

**Файл:** `src/transactions/transactions.service.spec.ts`

**Тестируемые методы:**
- `create()` - создание транзакции
- `findAll()` - получение всех транзакций пользователя
- `findById()` - получение транзакции по ID
- `getFinancialAnalytics()` - получение финансовой аналитики
- `getCategoryAnalytics()` - получение аналитики по категориям

**Пример теста:**
```typescript
describe('TransactionsService', () => {
  let service: TransactionsService;
  let mockDataSource: MockDataSource;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransactionsService,
        {
          provide: getRepositoryToken(Transaction),
          useValue: mockTransactionRepository,
        },
        {
          provide: MockDataSource,
          useValue: mockDataSource,
        },
      ],
    }).compile();

    service = module.get<TransactionsService>(TransactionsService);
  });

  it('должен создать транзакцию с категорией', async () => {
    const createDto = { amount: 100, type: 'expense', categoryId: 'cat-1' };

    const result = await service.create('user-1', createDto);

    expect(result).toBeDefined();
    expect(result.amount).toBe(100);
    expect(result.type).toBe('expense');
  });
});
```

#### 6.2.2 UsersService

**Файл:** `src/users/users.service.spec.ts`

**Тестируемые методы:**
- `create()` - создание пользователя
- `findAll()` - получение всех пользователей
- `findById()` - получение пользователя по ID
- `findByUsername()` - получение пользователя по username

**Особенности:**
- Тестирование хеширования паролей
- Тестирование валидации уникальности username

#### 6.2.3 CategoriesService

**Файл:** `src/categories/categories.service.spec.ts`

**Тестируемые методы:**
- `create()` - создание категории
- `findAll()` - получение всех категорий пользователя
- `findById()` - получение категории по ID
- `update()` - обновление категории
- `delete()` - удаление категории

**Особенности:**
- Тестирование уникальности категорий в рамках пользователя
- Тестирование валидации типа категории

#### 6.2.4 AuthService

**Файл:** `src/auth/auth.service.spec.ts`

**Тестируемые методы:**
- `signUp()` - регистрация пользователя
- `signIn()` - вход в систему
- `validateUser()` - валидация пользователя

**Особенности:**
- Тестирование генерации JWT токенов
- Тестирование проверки паролей
- Тестирование обработки ошибок аутентификации

### 6.3 Тестирование контроллеров

#### 6.3.1 TransactionsController

**Файл:** `src/transactions/transactions.controller.spec.ts`

**Тестируемые эндпоинты:**
- `POST /transactions` - создание транзакции
- `GET /transactions` - получение списка транзакций
- `GET /transactions/:id` - получение транзакции по ID
- `GET /transactions/analytics` - получение аналитики

**Особенности:**
- Мокирование сервисов
- Тестирование HTTP статус-кодов
- Тестирование валидации DTO

#### 6.3.2 CategoriesController

**Файл:** `src/categories/categories.controller.spec.ts`

**Тестируемые эндпоинты:**
- `POST /categories` - создание категории
- `GET /categories` - получение списка категорий
- `GET /categories/:id` - получение категории по ID
- `PATCH /categories/:id` - обновление категории
- `DELETE /categories/:id` - удаление категории

### 6.4 Использование MockDataSource

Все тесты используют `MockDataSource` для изоляции от реальной базы данных:

```typescript
const mockDataSource = {
  getTransactions: jest.fn(),
  createTransaction: jest.fn(),
  getCategories: jest.fn(),
  // ... другие методы
};
```

**Преимущества:**
- Тесты выполняются быстро
- Нет зависимости от состояния БД
- Легко тестировать граничные случаи
- Изоляция тестов друг от друга

### 6.5 Покрытие тестами

**Покрытые модули:**
- ✅ `TransactionsService` - тесты для создания, получения, аналитики
- ✅ `UsersService` - тесты для CRUD операций с пользователями
- ✅ `CategoriesService` - тесты для CRUD операций с категориями
- ✅ `AuthService` - тесты для аутентификации
- ✅ `TransactionsController` - тесты для HTTP эндпоинтов
- ✅ `CategoriesController` - тесты для HTTP эндпоинтов
- ✅ `AuthController` - тесты для HTTP эндпоинтов

**Запуск тестов:**
```bash
# Все тесты
npm test

# С покрытием
npm run test:cov

# В режиме watch
npm run test:watch
```

---

## 7. Список и описание рефакторингов (по итерациям). Перечислить паттерны GoF, примененные при рефакторинге

### 7.1 Первая версия приложения (v1.0)

**Характеристики первой версии:**
- Прямое использование TypeORM репозиториев в сервисах
- Отсутствие абстракции для работы с данными
- Нет поддержки разных источников данных
- Отсутствие обработки событий
- Базовая функциональность CRUD операций
- Простая структура без общего модуля

**Ограничения первой версии:**
- Тесная связанность сервисов с TypeORM
- Сложность тестирования (требовалась реальная БД)
- Невозможность переключения источников данных
- Отсутствие обработки событий транзакций
- Дублирование кода между модулями

### 7.2 Рефакторинг и вторая версия приложения (v2.0)

В процессе рефакторинга была проведена работа по улучшению архитектуры приложения с использованием паттернов проектирования GoF.

#### 7.2.1 Этап 1: Создание модуля `common/`

**Цель:** Вынести общие паттерны и утилиты в отдельный модуль.

**Действия:**
- Создан глобальный модуль `common/`
- Организована структура для паттернов проектирования

**Структура:**
```
src/common/
├── repositories/      # Repository Pattern
├── data-sources/      # Strategy и Abstract Factory
└── observers/         # Observer Pattern
```

**Примененные паттерны:** Модульная архитектура

---

#### 7.2.2 Этап 2: Внедрение Repository Pattern

**Цель:** Абстрагировать работу с данными от конкретной реализации хранилища.

**Действия:**
- Создан абстрактный класс `AbstractRepository<T>`
- Реализованы конкретные репозитории: `TransactionRepository`, `CategoryRepository`
- Сервисы переведены на использование репозиториев вместо прямого обращения к TypeORM

**Код до рефакторинга:**
```typescript
// Прямое использование TypeORM
@Injectable()
export class TransactionsService {
  constructor(
    @InjectRepository(Transaction)
    private transactionRepository: Repository<Transaction>,
  ) {}
}
```

**Код после рефакторинга:**
```typescript
// Использование Repository Pattern
@Injectable()
export class TransactionsService {
  constructor(
    private transactionRepository: TransactionRepository,
  ) {}
}
```

**Примененные паттерны GoF:**
- **Repository Pattern** - абстракция для работы с данными

**Преимущества:**
- Изоляция бизнес-логики от деталей работы с БД
- Возможность легкой замены источника данных
- Упрощение тестирования через моки

---

#### 7.2.3 Этап 3: Внедрение Strategy Pattern и Abstract Factory

**Цель:** Обеспечить возможность переключения между источниками данных.

**Действия:**
- Создан интерфейс `IDataSource` для абстракции источников данных
- Реализованы стратегии: `DatabaseDataSource` (PostgreSQL) и `MockDataSource` (память)
- Создана фабрика `DataSourceFactoryImpl` для централизованного создания источников

**Код реализации Strategy Pattern:**
```typescript
// Интерфейс стратегии
export interface IDataSource {
  getTransactions(userId: string): Promise<Transaction[]>;
  createTransaction(userId: string, transaction: Partial<Transaction>): Promise<Transaction>;
  // ... другие методы
}

// Конкретные стратегии
export class DatabaseDataSource implements IDataSource { ... }
export class MockDataSource implements IDataSource { ... }
```

**Код реализации Abstract Factory Pattern:**
```typescript
// Абстрактная фабрика
export abstract class DataSourceFactory {
  abstract createDataSource(): IDataSource;
}

// Конкретная фабрика
export class DataSourceFactoryImpl extends DataSourceFactory {
  createDataSource(): IDataSource {
    const type = this.configService.get<string>('DATA_SOURCE_TYPE', 'database');
    switch (type) {
      case DataSourceType.MOCK:
        return this.mockDataSource;
      case DataSourceType.DATABASE:
      default:
        return this.databaseDataSource;
    }
  }
}
```

**Примененные паттерны GoF:**
- **Strategy Pattern** - выбор алгоритма работы с данными во время выполнения
- **Abstract Factory Pattern** - создание семейств связанных объектов (источников данных)

**Преимущества:**
- Легкое переключение между источниками данных
- Возможность добавления новых источников (например, файловый)
- Изоляция логики работы с данными
- Конфигурируемость через переменные окружения

---

#### 7.2.4 Этап 4: Внедрение Observer Pattern

**Цель:** Реализовать слабосвязанную обработку событий транзакций.

**Действия:**
- Создан интерфейс `ITransactionObserver` и класс `TransactionSubject`
- Реализован `AnalyticsObserver` для логирования событий транзакций
- Интегрирован в `TransactionsService` для уведомления о создании транзакций

**Код реализации Observer Pattern:**
```typescript
// Интерфейс наблюдателя
export interface ITransactionObserver {
  onTransactionCreated(transaction: Transaction): Promise<void> | void;
  onTransactionUpdated(transaction: Transaction): Promise<void> | void;
  onTransactionDeleted(transactionId: string): Promise<void> | void;
}

// Субъект
export class TransactionSubject {
  private observers: ITransactionObserver[] = [];

  attach(observer: ITransactionObserver): void {
    this.observers.push(observer);
  }

  async notifyTransactionCreated(transaction: Transaction): Promise<void> {
    await Promise.all(
      this.observers.map(observer => 
        Promise.resolve(observer.onTransactionCreated(transaction))
      )
    );
  }
}

// Конкретный наблюдатель
export class AnalyticsObserver extends AbstractTransactionObserver {
  onTransactionCreated(transaction: Transaction): void {
    this.logger.log(`Transaction created: ${transaction.id}`);
  }
}
```

**Примененные паттерны GoF:**
- **Observer Pattern** - зависимость "один ко многим" между объектами

**Преимущества:**
- Слабая связанность между компонентами
- Легкое добавление новых наблюдателей
- Возможность обработки событий асинхронно

---

#### 7.2.5 Этап 5: Добавление финансовой аналитики

**Цель:** Реализовать функциональность финансовой аналитики после рефакторинга.

**Действия:**
- Добавлен метод `getFinancialAnalytics()` - общая финансовая статистика
- Добавлен метод `getCategoryAnalytics()` - детальная аналитика по категориям
- Реализована фильтрация по датам для анализа периодов
- Алгоритмические вычисления на бекенде

**Примененные паттерны:** Алгоритмические паттерны (группировка, агрегация)

---

### 7.3 Сравнение версий

| Аспект               | Версия 1.0                   | Версия 2.0                       |
| -------------------- | ---------------------------- | -------------------------------- |
| Архитектура          | Упрощенная, без паттернов    | Многослойная с паттернами GoF    |
| Работа с данными     | Прямое использование TypeORM | Через Repository Pattern         |
| Источники данных     | Только PostgreSQL            | PostgreSQL + Mock (расширяемо)   |
| Обработка событий    | Отсутствует                  | Observer Pattern                 |
| Тестирование         | Требует реальную БД          | Мокирование через MockDataSource |
| Финансовая аналитика | Отсутствует                  | Полная аналитика с фильтрацией   |
| Модуль common/       | Отсутствует                  | Реализован со всеми паттернами   |

### 7.4 Сводная таблица примененных паттернов GoF

| Паттерн                    | Категория      | Применение                                    | Файлы реализации                    |
| -------------------------- | -------------- | --------------------------------------------- | ----------------------------------- |
| Repository Pattern         | Структурный    | Абстракция работы с данными                   | `src/common/repositories/`          |
| Strategy Pattern           | Поведенческий  | Выбор источника данных во время выполнения   | `src/common/data-sources/`          |
| Abstract Factory Pattern   | Порождающий    | Создание источников данных                    | `src/common/data-sources/`           |
| Observer Pattern           | Поведенческий  | Обработка событий транзакций                  | `src/common/observers/`             |

### 7.5 Преимущества рефакторинга

1. **Гибкость** - легко добавлять новые источники данных и наблюдатели
2. **Тестируемость** - изоляция через моки, быстрые тесты
3. **Расширяемость** - четкая структура для добавления функциональности
4. **Поддерживаемость** - разделение ответственности, понятная архитектура
5. **Переиспользование** - общие паттерны в модуле `common/`

---

## 8. Упаковка проекта, метрики упаковки (в т.ч. - докер, если есть, вопросы CI/CD, взаимодействие сервисов и компонентов через RabbitMQ – если будет). Нужно привести результаты отдельных итераций / версий как результаты набора коммитов в системе контроля версий

### 8.1 Упаковка проекта в Docker

#### 8.1.1 Dockerfile

Проект использует многоэтапную сборку Docker для оптимизации размера образа:

**Файл:** `Dockerfile`

```dockerfile
# STAGE 1: BUILD
FROM node:22.13.0-alpine AS builder

WORKDIR /app

# Установка зависимостей
COPY package*.json ./
RUN npm ci

# Копирование исходников
COPY . .

# Сборка TypeScript
RUN npm run build

# STAGE 2: RUN
FROM node:22.13.0-alpine

WORKDIR /app

# Установка только прод-зависимостей
COPY package*.json ./
RUN npm ci --omit=dev

# Копирование собранного build
COPY --from=builder /app/dist ./dist

# Экспонирование порта
EXPOSE 8080

# Команда запуска
CMD ["node", "dist/main.js"]
```

**Особенности:**
- Многоэтапная сборка для уменьшения размера образа
- Использование Alpine Linux для минимального размера
- Разделение зависимостей разработки и production

#### 8.1.2 Docker Compose

**Файл:** `docker-compose.yaml`

```yaml
name: cashflow_dev

services:
  api:
    build: .
    container_name: cashflow_api
    env_file: .env.docker
    ports:
      - "8081:8080"
    depends_on:
      database:
        condition: service_healthy
    environment:
      DATABASE_HOST: database
      DATABASE_PORT: 5432
    networks:
      - internal

  database:
    image: postgres:17
    env_file: .env.docker
    container_name: cashflow_database
    environment:
      POSTGRES_USER: ${DATABASE_USER}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
      POSTGRES_DB: ${DATABASE_NAME}
    volumes:
      - pg_data:/var/lib/postgresql/data
    ports:
      - "5431:5432"
    networks:
      - internal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER}"]
      interval: 2s
      timeout: 3s
      retries: 10

volumes:
  pg_data:

networks:
  internal:
```

**Компоненты:**
- **API Container** - контейнер с приложением NestJS (порт 8081:8080)
- **Database Container** - контейнер с PostgreSQL (порт 5431:5432)
- **Internal Network** - изолированная сеть для связи между контейнерами
- **Volume** - постоянное хранилище для данных БД

**Преимущества:**
- Изоляция окружения разработки и production
- Легкое масштабирование
- Консистентность между различными средами
- Упрощение CI/CD процессов

#### 8.1.3 Команды для работы с Docker

```bash
# Сборка и запуск контейнеров
docker compose up --build

# Запуск в фоновом режиме
docker compose up -d

# Остановка контейнеров
docker compose down

# Просмотр логов
docker compose logs -f api

# Пересборка без кэша
docker compose build --no-cache
```

### 8.2 Метрики упаковки

#### 8.2.1 Размеры образов

**API образ:**
- Базовый образ (node:22.13.0-alpine): ~180 MB
- С зависимостями production: ~250 MB
- С зависимостями разработки: ~450 MB (не используется в production)

**Database образ:**
- postgres:17: ~400 MB

**Общий размер:**
- ~650 MB для полного стека (API + Database)

#### 8.2.2 Оптимизации

1. **Многоэтапная сборка** - уменьшение размера финального образа
2. **Alpine Linux** - минимальный базовый образ
3. **Отделение dev-зависимостей** - только production зависимости в финальном образе
4. **Минификация кода** - TypeScript компилируется в оптимизированный JavaScript

### 8.3 Версионирование и коммиты

#### 8.3.1 Структура версий

Проект следует семантическому версионированию:

- **v1.0.x** - первая версия с базовой функциональностью
- **v2.0.x** - вторая версия с рефакторингом и паттернами

#### 8.3.2 История коммитов по итерациям

**Итерация 1 (v1.0):**
```
commit: "feat: add authentication module (UC1, UC2)"
- Добавлен модуль аутентификации
- Реализована регистрация и вход
- Настроен JWT

commit: "feat: add users module"
- Создана сущность User
- Реализован UsersService
- Настроена связь с БД
```

**Итерация 2 (v1.0):**
```
commit: "feat: add transactions module (UC3, UC4, UC5)"
- Создана сущность Transaction
- Реализован TransactionsService
- Добавлены CRUD операции

commit: "feat: add transaction validation"
- Валидация данных транзакций
- Проверка принадлежности пользователю
```

**Итерация 3 (v1.0):**
```
commit: "feat: add financial analytics (UC6, UC7)"
- Реализована общая финансовая аналитика
- Добавлена аналитика по категориям
- Фильтрация по датам
```

**Итерация 4 (v1.0):**
```
commit: "feat: add categories module (UC8, UC9, UC10)"
- Создана сущность Category
- Реализован CategoriesService
- Настроены связи с User и Transaction

commit: "feat: auto-create default categories on signup"
- Автоматическое создание категорий при регистрации
```

**Итерация 5 (v1.0):**
```
commit: "feat: add category update and delete (UC11, UC12)"
- Реализовано обновление категорий
- Реализовано удаление категорий
- Обработка каскадного удаления
```

**Итерация 6 (v2.0 - Рефакторинг):**
```
commit: "refactor: create common module for design patterns"
- Создан модуль common/
- Организована структура для паттернов

commit: "refactor: implement Repository Pattern"
- Создан AbstractRepository
- Реализованы TransactionRepository и CategoryRepository
- Рефакторинг сервисов для использования репозиториев

commit: "refactor: implement Strategy Pattern for data sources"
- Создан интерфейс IDataSource
- Реализованы DatabaseDataSource и MockDataSource

commit: "refactor: implement Abstract Factory Pattern"
- Создана DataSourceFactory
- Реализована DataSourceFactoryImpl

commit: "refactor: implement Observer Pattern"
- Создан TransactionSubject
- Реализован AnalyticsObserver
- Интеграция в TransactionsService
```

**Итерация 7 (v2.0 - Тестирование):**
```
commit: "test: add unit tests for services"
- Тесты для TransactionsService
- Тесты для UsersService
- Тесты для CategoriesService
- Использование MockDataSource

commit: "test: add controller tests"
- Тесты для TransactionsController
- Тесты для CategoriesController
- Тесты для AuthController
```

### 8.4 CI/CD (Continuous Integration / Continuous Deployment)

#### 8.4.1 Текущее состояние

В текущей версии проекта CI/CD не настроен, но архитектура готова для его внедрения.

#### 8.4.2 Рекомендации по CI/CD

**GitHub Actions / GitLab CI пример:**

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '22'
      - run: npm ci
      - run: npm run test
      - run: npm run test:cov

  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker compose build
      - name: Test Docker image
        run: docker compose up -d && sleep 10 && docker compose down
```

**Этапы CI/CD:**
1. **Lint** - проверка кода
2. **Test** - запуск тестов
3. **Build** - сборка Docker образа
4. **Deploy** - развертывание (при необходимости)

### 8.5 Взаимодействие сервисов

#### 8.5.1 Текущая архитектура

В текущей версии приложение монолитное, все компоненты работают в одном процессе. Взаимодействие происходит через:

- **Dependency Injection** - NestJS управляет зависимостями
- **Модульная структура** - четкое разделение на модули
- **События через Observer Pattern** - слабосвязанное взаимодействие

#### 8.5.2 RabbitMQ (будущее расширение)

В текущей версии RabbitMQ не используется, но архитектура позволяет легко добавить его для:

- **Асинхронной обработки событий** - через очереди сообщений
- **Микросервисной архитектуры** - взаимодействие между сервисами
- **Обработки аналитики** - фоновые задачи для вычисления статистики

**Пример интеграции (будущее):**
```typescript
// Пример использования RabbitMQ для асинхронной аналитики
@Injectable()
export class AnalyticsQueueService {
  constructor(
    @InjectQueue('analytics') private analyticsQueue: Queue,
  ) {}

  async queueAnalyticsUpdate(userId: string) {
    await this.analyticsQueue.add('update-analytics', { userId });
  }
}
```

### 8.6 Метрики проекта

#### 8.6.1 Размер кодовой базы

- **Общее количество файлов:** ~50
- **Строк кода (TypeScript):** ~3000+
- **Модули:** 5 основных модулей (auth, users, categories, transactions, common)
- **Тесты:** 9 тестовых файлов

#### 8.6.2 Зависимости

**Production зависимости:**
- @nestjs/common, @nestjs/core
- @nestjs/typeorm, typeorm
- @nestjs/jwt
- pg (PostgreSQL driver)
- bcrypt

**Development зависимости:**
- @nestjs/testing
- jest, ts-jest
- typescript
- eslint, prettier

### 8.7 Развертывание

#### 8.7.1 Локальное развертывание

```bash
# Клонирование репозитория
git clone <repository-url>
cd cashflow-api

# Настройка переменных окружения
cp .env.example .env.docker

# Запуск через Docker Compose
docker compose up --build
```

#### 8.7.2 Production развертывание

**Рекомендации:**
1. Использовать переменные окружения для конфигурации
2. Настроить health checks для контейнеров
3. Использовать reverse proxy (nginx) для балансировки нагрузки
4. Настроить мониторинг и логирование
5. Использовать секреты для хранения паролей и токенов

---

## Заключение

В ходе выполнения контрольной работы было разработано REST API приложение для управления личными финансами с использованием современных технологий (NestJS, TypeORM, PostgreSQL) и паттернов проектирования GoF.

Проект был разработан итеративно, начиная с базовой функциональности (v1.0) и постепенно улучшая архитектуру через рефакторинг с применением паттернов проектирования (v2.0).

Приложение упаковано в Docker контейнеры, что обеспечивает консистентность окружения и упрощает развертывание. Код покрыт модульными тестами с использованием моков для изоляции от реальной базы данных.

Архитектура приложения готова для дальнейшего расширения, включая возможность добавления CI/CD, интеграции с RabbitMQ для асинхронной обработки и перехода к микросервисной архитектуре.
