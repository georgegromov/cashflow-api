# Контрольная работа

по дисциплине: Введение в разработку программного обеспечения

на тему: Создание приложения с использованием паттернов проектирования

---

## Содержание

1. [Введение](#введение)
2. [Постановка задачи, варианты использования и планирование](#постановка-задачи-варианты-использования-и-планирование)
3. [Архитектура проекта и реализованные паттерны](#архитектура-проекта-и-реализованные-паттерны)
   - 3.1 [Общая архитектура и паттерны](#31-общая-архитектура-и-паттерны)
   - 3.2 [Repository Pattern](#32-repository-pattern)
   - 3.3 [Strategy Pattern](#33-strategy-pattern)
   - 3.4 [Abstract Factory Pattern](#34-abstract-factory-pattern)
   - 3.5 [Observer Pattern](#35-observer-pattern)
   - 3.6 [Модульные тесты с мокированием](#36-модульные-тесты-с-мокированием)
   - 3.7 [Эволюция проекта: версии и рефакторинг](#37-эволюция-проекта-версии-и-рефакторинг)
4. [Заключение](#заключение)
5. [Список использованных источников](#список-использованных-источников)

---

## Введение

В данной работе рассматривается REST API приложение для управления личными финансами (CashFlow API), разработанное на платформе NestJS с использованием TypeScript. Приложение позволяет пользователям отслеживать доходы и расходы, управлять категориями транзакций и получать финансовую аналитику.

Приложение работает с разными источниками данных, включая базу данных PostgreSQL (через TypeORM), а также моковый источник данных для тестирования. Технологии реализации: NestJS, TypeORM, PostgreSQL, JWT для аутентификации, Swagger для документации API.

В проекте реализованы следующие паттерны проектирования GoF (Gang of Four):

- **Repository Pattern** - для абстракции работы с данными
- **Strategy Pattern** - для работы с разными источниками данных
- **Abstract Factory Pattern** - для создания источников данных
- **Observer Pattern** - для обработки событий транзакций

---

## Постановка задачи, варианты использования и планирование

### Постановка задачи

Необходимо разработать REST API приложение для управления личными финансами с поддержкой:

- Аутентификации и авторизации пользователей
- Управления категориями доходов и расходов
- Создания и управления транзакциями
- Получения финансовой аналитики

Приложение должно поддерживать разные источники данных, включая базу данных PostgreSQL и моковый источник для тестирования.

### Варианты использования (Use Cases)

| №    | Название                          | Описание                                          | Сложность |
| ---- | --------------------------------- | ------------------------------------------------- | --------- |
| UC1  | Регистрация пользователя          | Пользователь создает новый аккаунт                | Средняя   |
| UC2  | Вход в систему                    | Пользователь авторизуется в системе               | Низкая    |
| UC3  | Создание транзакции               | Пользователь создает новую транзакцию             | Средняя   |
| UC4  | Просмотр списка транзакций        | Пользователь получает список всех транзакций      | Низкая    |
| UC5  | Просмотр транзакции по ID         | Пользователь получает детали транзакции           | Низкая    |
| UC6  | Получение финансовой аналитики    | Пользователь получает общую финансовую статистику | Высокая   |
| UC7  | Получение аналитики по категориям | Пользователь получает статистику по категориям    | Высокая   |
| UC8  | Создание категории                | Пользователь создает новую категорию              | Низкая    |
| UC9  | Просмотр списка категорий         | Пользователь получает список всех категорий       | Низкая    |
| UC10 | Просмотр категории по ID          | Пользователь получает детали категории            | Низкая    |
| UC11 | Обновление категории              | Пользователь обновляет данные категории           | Средняя   |
| UC12 | Удаление категории                | Пользователь удаляет категорию                    | Средняя   |

Подробное описание всех use cases представлено в файле `docs/USE_CASES.md`.

### Планирование

Таблица 1 – План версий и итераций

| История              | Сложность (ид. дней) | № итерации | № версии |
| -------------------- | -------------------- | ---------- | -------- |
| UC1, UC2             | 2                    | 1          | 1        |
| UC3, UC4, UC5        | 3                    | 2          | 1        |
| UC6, UC7             | 4                    | 3          | 1        |
| UC8, UC9, UC10       | 2                    | 4          | 1        |
| UC11, UC12           | 2                    | 5          | 1        |
| Реализация паттернов | 3                    | 6          | 2        |
| Моковые тесты        | 2                    | 7          | 2        |

---

## Архитектура проекта и реализованные паттерны

### 3.1 Общая архитектура и паттерны

#### 3.1.1 Архитектура приложения

Проект построен на основе **многослойной архитектуры (Layered Architecture)** с использованием фреймворка NestJS. Архитектура следует принципам разделения ответственности и обеспечивает четкое разделение между слоями представления, бизнес-логики и доступа к данным.

**Слои архитектуры:**

1. **Controller Layer (Слой контроллеров)** - обрабатывает HTTP-запросы, валидацию входных данных и формирование ответов
2. **Service Layer (Слой сервисов)** - содержит бизнес-логику приложения
3. **Repository Layer (Слой репозиториев)** - абстрагирует доступ к данным
4. **Entity Layer (Слой сущностей)** - модели предметной области

**Модель предметной области:**

Приложение оперирует тремя основными сущностями. Базовая иерархия классов предметной области представлена на диаграмме `docs/diagrams/domain-model.puml`:

- **User** (Пользователь) - центральная сущность системы, содержит информацию о пользователе (id, username, password_hash)
- **Transaction** (Транзакция) - доходы и расходы пользователя (amount, type, note, category)
- **Category** (Категория) - группировка транзакций по типам (name, type: income/expense)

Связи между сущностями:

- User 1:N Transaction (один пользователь имеет множество транзакций)
- User 1:N Category (один пользователь имеет множество категорий)
- Transaction N:0..1 Category (транзакция может относиться к категории или не иметь её)

**Структура модулей:**

Каждый функциональный модуль (Users, Categories, Transactions, Auth) организован по единому принципу:

```
module/
├── entities/          # Сущности предметной области
├── dto/              # Data Transfer Objects (DTO)
├── interfaces/       # Интерфейсы для типизации
├── module.controller.ts  # Контроллер (обработка HTTP)
├── module.service.ts     # Сервис (бизнес-логика)
└── module.module.ts      # Модуль NestJS
```

**Полная структура проекта:**

```
src/
├── auth/              # Модуль аутентификации
│   ├── guards/        # Guards для защиты маршрутов
│   ├── decorators/    # Кастомные декораторы
│   └── ...
├── users/             # Модуль пользователей
│   ├── entities/      # User entity
│   ├── dto/           # DTO для создания/обновления
│   └── ...
├── categories/        # Модуль категорий
│   ├── entities/      # Category entity
│   ├── dto/           # DTO для категорий
│   └── ...
├── transactions/      # Модуль транзакций
│   ├── entities/      # Transaction entity
│   ├── dto/           # DTO для транзакций и аналитики
│   └── ...
├── common/            # Общие паттерны и утилиты (создан при рефакторинге)
│   ├── repositories/  # Repository Pattern
│   ├── data-sources/  # Strategy и Abstract Factory
│   └── observers/      # Observer Pattern
└── database/          # Конфигурация БД
    └── orm/           # TypeORM конфигурация
```

#### 3.1.2 Развертывание с использованием Docker

Приложение упаковано в Docker-контейнеры для обеспечения консистентности окружения и упрощения развертывания. Используется **Docker Compose** для оркестрации контейнеров.

**Архитектура контейнеров:**

- **API Container** - контейнер с приложением NestJS (порт 8081:8080)
- **Database Container** - контейнер с PostgreSQL (порт 5431:5432)
- **Internal Network** - изолированная сеть для связи между контейнерами

**Преимущества Docker:**

- Изоляция окружения разработки и production
- Легкое масштабирование
- Консистентность между различными средами
- Упрощение CI/CD процессов

#### 3.1.3 Реализованные паттерны проектирования

Для обеспечения гибкости, расширяемости и поддерживаемости кода в проекте реализованы следующие паттерны проектирования GoF:

1. **Repository Pattern** - абстракция для работы с данными, изоляция бизнес-логики от деталей БД
2. **Strategy Pattern** - выбор алгоритма работы с данными во время выполнения (БД, мок, файл)
3. **Abstract Factory Pattern** - централизованное создание источников данных
4. **Observer Pattern** - слабосвязанная обработка событий транзакций

Все паттерны реализованы в модуле `common/`, который был создан в процессе рефакторинга (см. раздел 3.7).

### 3.2 Repository Pattern

**Цель:** Абстрагировать работу с данными от конкретной реализации хранилища.

**Реализация:**

В процессе рефакторинга был создан абстрактный класс `AbstractRepository<T>`, который определяет базовый интерфейс для работы с данными:

```typescript
export abstract class AbstractRepository<T> {
  abstract findAll(): Promise<T[]>;
  abstract findById(id: string): Promise<T | null>;
  abstract create(entity: Partial<T>): Promise<T>;
  abstract update(id: string, entity: Partial<T>): Promise<T>;
  abstract delete(id: string): Promise<boolean>;
  abstract findBy(condition: Partial<T>): Promise<T[]>;
}
```

**Преимущества:**

- Изоляция бизнес-логики от деталей работы с БД
- Возможность легкой замены источника данных
- Упрощение тестирования через моки

### 3.3 Strategy Pattern

**Цель:** Позволить приложению выбирать алгоритм работы с данными во время выполнения.

**Реализация:**

В модуле `common/data-sources/` создан интерфейс `IDataSource`, который определяет стратегию работы с данными:

```typescript
export interface IDataSource {
  getTransactions(userId: string): Promise<Transaction[]>;
  getTransactionById(id: string, userId: string): Promise<Transaction | null>;
  createTransaction(
    userId: string,
    transaction: Partial<Transaction>,
  ): Promise<Transaction>;
  // ... другие методы
}
```

Реализованы две стратегии:

1. **DatabaseDataSource** - работа с PostgreSQL через TypeORM
2. **MockDataSource** - работа с данными в памяти для тестирования

**Преимущества:**

- Легкое переключение между источниками данных
- Возможность добавления новых источников (например, файловый)
- Изоляция логики работы с данными

**Пример использования:**

```typescript
// В конфигурации можно указать тип источника данных
const dataSource = dataSourceFactory.createDataSourceByType(
  DataSourceType.MOCK,
);
```

### 3.4 Abstract Factory Pattern

**Цель:** Создание семейств связанных объектов (источников данных) без указания их конкретных классов.

**Реализация:**

В модуле `common/data-sources/` создана абстрактная фабрика `DataSourceFactory` и её реализация `DataSourceFactoryImpl`:

```typescript
export abstract class DataSourceFactory {
  abstract createDataSource(): IDataSource;
}

export class DataSourceFactoryImpl extends DataSourceFactory {
  createDataSource(): IDataSource {
    const dataSourceType = this.configService.get<string>(
      'DATA_SOURCE_TYPE',
      'database',
    );

    switch (dataSourceType) {
      case DataSourceType.MOCK:
        return this.mockDataSource;
      case DataSourceType.DATABASE:
      default:
        return this.databaseDataSource;
    }
  }
}
```

**Преимущества:**

- Централизованное создание источников данных
- Легкое добавление новых типов источников
- Конфигурируемость через переменные окружения

### 3.5 Observer Pattern

**Цель:** Определить зависимость "один ко многим" между объектами так, чтобы при изменении состояния одного объекта все зависящие от него объекты получали уведомление.

**Реализация:**

В модуле `common/observers/` создан интерфейс `ITransactionObserver` и класс `TransactionSubject`:

```typescript
export interface ITransactionObserver {
  onTransactionCreated(transaction: Transaction): Promise<void> | void;
  onTransactionUpdated(transaction: Transaction): Promise<void> | void;
  onTransactionDeleted(transactionId: string): Promise<void> | void;
}

export class TransactionSubject {
  private observers: ITransactionObserver[] = [];

  attach(observer: ITransactionObserver): void { ... }
  detach(observer: ITransactionObserver): void { ... }
  async notifyTransactionCreated(transaction: Transaction): Promise<void> { ... }
}
```

Реализован конкретный наблюдатель `AnalyticsObserver` для логирования событий:

```typescript
@Injectable()
export class AnalyticsObserver extends AbstractTransactionObserver {
  async onTransactionCreated(transaction: Transaction): Promise<void> {
    this.logger.log(`Transaction created: ${transaction.id}`);
    // Здесь можно добавить логику для обновления аналитики
  }
}
```

**Преимущества:**

- Слабая связанность между компонентами
- Легкое добавление новых наблюдателей
- Возможность обработки событий асинхронно

**Пример использования:**

```typescript
// Подписка на события
transactionSubject.attach(analyticsObserver);

// Уведомление наблюдателей
await transactionSubject.notifyTransactionCreated(transaction);
```

### 3.6 Модульные тесты с мокированием

Для обеспечения качества кода написаны модульные тесты с использованием моков. Все тесты используют `MockDataSource` для изоляции от реальной базы данных.

**Пример теста для TransactionsService:**

```typescript
describe('TransactionsService', () => {
  let service: TransactionsService;
  let mockDataSource: MockDataSource;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransactionsService,
        {
          provide: getRepositoryToken(Transaction),
          useValue: mockTransactionRepository,
        },
        {
          provide: MockDataSource,
          useValue: mockDataSource,
        },
      ],
    }).compile();

    service = module.get<TransactionsService>(TransactionsService);
  });

  it('должен создать транзакцию с категорией', async () => {
    // Arrange
    const createDto = { amount: 100, type: 'expense', categoryId: 'cat-1' };

    // Act
    const result = await service.create('user-1', createDto);

    // Assert
    expect(result).toBeDefined();
  });
});
```

**Покрытие тестами:**

- `TransactionsService` - тесты для создания, получения, аналитики
- `UsersService` - тесты для CRUD операций с пользователями
- `CategoriesService` - тесты для CRUD операций с категориями

**Преимущества мокирования:**

- Быстрое выполнение тестов (без обращения к БД)
- Изоляция тестов друг от друга
- Возможность тестирования граничных случаев

### 3.7 Эволюция проекта: версии и рефакторинг

#### 3.7.1 Первая версия приложения (v1.0)

Первая версия приложения была реализована с базовой функциональностью для выполнения основных use cases (UC1-UC12). Архитектура была упрощенной и не использовала паттерны проектирования.

**Характеристики первой версии:**

- Прямое использование TypeORM репозиториев в сервисах
- Отсутствие абстракции для работы с данными
- Нет поддержки разных источников данных
- Отсутствие обработки событий
- Базовая функциональность CRUD операций
- Простая структура без общего модуля

**Структура первой версии:**

```
src/
├── auth/
├── users/
├── categories/
├── transactions/
└── database/
```

**Ограничения первой версии:**

- Тесная связанность сервисов с TypeORM
- Сложность тестирования (требовалась реальная БД)
- Невозможность переключения источников данных
- Отсутствие обработки событий транзакций
- Дублирование кода между модулями

#### 3.7.2 Рефакторинг и вторая версия приложения (v2.0)

В процессе рефакторинга была проведена работа по улучшению архитектуры приложения с использованием паттернов проектирования GoF. Основной целью было повышение гибкости, расширяемости и тестируемости кода.

**Этапы рефакторинга:**

**Этап 1: Создание модуля `common/`**

Был создан глобальный модуль `common/`, который инкапсулирует общие паттерны и утилиты:

```
src/common/
├── repositories/      # Repository Pattern
│   ├── abstract.repository.ts
│   ├── transaction.repository.ts
│   └── category.repository.ts
├── data-sources/      # Strategy и Abstract Factory
│   ├── data-source.interface.ts
│   ├── database.data-source.ts
│   ├── mock.data-source.ts
│   └── data-source.factory.ts
└── observers/         # Observer Pattern
    ├── transaction.observer.ts
    └── analytics.observer.ts
```

**Этап 2: Внедрение Repository Pattern**

- Создан абстрактный класс `AbstractRepository<T>` для унификации работы с данными
- Реализованы конкретные репозитории: `TransactionRepository`, `CategoryRepository`
- Сервисы переведены на использование репозиториев вместо прямого обращения к TypeORM

**Результат:** Изоляция бизнес-логики от деталей работы с БД, упрощение тестирования.

**Этап 3: Внедрение Strategy Pattern и Abstract Factory**

- Создан интерфейс `IDataSource` для абстракции источников данных
- Реализованы стратегии: `DatabaseDataSource` (PostgreSQL) и `MockDataSource` (память)
- Создана фабрика `DataSourceFactoryImpl` для централизованного создания источников

**Результат:** Возможность переключения между источниками данных без изменения бизнес-логики.

**Этап 4: Внедрение Observer Pattern**

- Создан интерфейс `ITransactionObserver` и класс `TransactionSubject`
- Реализован `AnalyticsObserver` для логирования событий транзакций
- Интегрирован в `TransactionsService` для уведомления о создании транзакций

**Результат:** Слабая связанность компонентов, возможность добавления новых наблюдателей.

**Этап 5: Добавление финансовой аналитики**

После рефакторинга была добавлена функциональность финансовой аналитики:

- Метод `getFinancialAnalytics()` - общая финансовая статистика (доходы, расходы, баланс)
- Метод `getCategoryAnalytics()` - детальная аналитика по категориям
- Фильтрация по датам для анализа периодов
- Алгоритмические вычисления на бекенде

**Характеристики второй версии:**

- Модульная архитектура с разделением ответственности
- Использование паттернов GoF для гибкости и расширяемости
- Поддержка разных источников данных (БД, мок)
- Обработка событий через Observer Pattern
- Улучшенная тестируемость через мокирование
- Финансовая аналитика с фильтрацией по датам

**Сравнение версий:**

| Аспект               | Версия 1.0                   | Версия 2.0                       |
| -------------------- | ---------------------------- | -------------------------------- |
| Архитектура          | Упрощенная, без паттернов    | Многослойная с паттернами GoF    |
| Работа с данными     | Прямое использование TypeORM | Через Repository Pattern         |
| Источники данных     | Только PostgreSQL            | PostgreSQL + Mock (расширяемо)   |
| Обработка событий    | Отсутствует                  | Observer Pattern                 |
| Тестирование         | Требует реальную БД          | Мокирование через MockDataSource |
| Финансовая аналитика | Отсутствует                  | Полная аналитика с фильтрацией   |
| Модуль common/       | Отсутствует                  | Реализован со всеми паттернами   |

**Преимущества рефакторинга:**

1. **Гибкость** - легко добавлять новые источники данных и наблюдатели
2. **Тестируемость** - изоляция через моки, быстрые тесты
3. **Расширяемость** - четкая структура для добавления функциональности
4. **Поддерживаемость** - разделение ответственности, понятная архитектура
5. **Переиспользование** - общие паттерны в модуле `common/`

---

## Заключение

В ходе выполнения работы было разработано REST API приложение для управления личными финансами с использованием современных технологий (NestJS, TypeORM, PostgreSQL) и паттернов проектирования.

Реализованные паттерны GoF позволили:

- **Repository Pattern** - абстрагировать работу с данными и упростить тестирование
- **Strategy Pattern** - обеспечить гибкость в выборе источника данных
- **Abstract Factory Pattern** - централизовать создание источников данных
- **Observer Pattern** - реализовать слабосвязанную обработку событий

Приложение поддерживает все заявленные use cases, имеет модульную архитектуру, покрыто модульными тестами с использованием моков. Код следует принципам SOLID и best practices NestJS.

Дальнейшее развитие проекта может включать:

- Добавление файлового источника данных (CSV, JSON)
- Реализацию кэширования для улучшения производительности
- Добавление веб-сокетов для real-time обновлений
- Расширение аналитики (графики, прогнозы)

---

## Список использованных источников

1. NestJS Documentation. [Электронный ресурс] Режим доступа: https://docs.nestjs.com/ (дата обращения: 2025-01-XX)

2. TypeORM Documentation. [Электронный ресурс] Режим доступа: https://typeorm.io/ (дата обращения: 2025-01-XX)

3. Gamma, E., Helm, R., Johnson, R., Vlissides, J. Design Patterns: Elements of Reusable Object-Oriented Software. - Addison-Wesley Professional, 1994.

4. Паттерны проектирования в TypeScript [Электронный ресурс] Режим доступа: https://refactoring.guru/ru/design-patterns/typescript (дата обращения: 2025-01-XX)

5. SOLID Principles [Электронный ресурс] Режим доступа: https://en.wikipedia.org/wiki/SOLID (дата обращения: 2025-01-XX)

6. Jest Documentation. [Электронный ресурс] Режим доступа: https://jestjs.io/ (дата обращения: 2025-01-XX)

7. Андреев, А.Е. Адаптивные технологии разработки программного обеспечения: учеб. пособие / А.Е. Андреев, С.И. Кирносенко; ВолгГТУ. - Волгоград, 2015. - 95 с.
